<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#0b1220">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>æ’­æ”¾ä¸­</title>
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <style>
    :root {
      --bg: #0b1220;
      --card: #111b2e;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #4ade80;
      --accent-dim: rgba(74, 222, 128, 0.15);
      --line: #1e293b;
      --danger: #f87171;
      --warning: #fbbf24;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { background: #000; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      padding-top: calc(12px + env(safe-area-inset-top, 0));
      background: rgba(11, 18, 32, 0.95);
      border-bottom: 1px solid var(--line);
    }
    .back-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 10px;
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--text);
      text-decoration: none;
      font-size: 14px;
    }
    .back-btn:active { opacity: 0.7; }
    .header-title {
      flex: 1;
      font-size: 16px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .video-container { background: #000; position: relative; }
    video {
      width: 100%;
      height: auto;
      max-height: 56.25vw;
      background: #000;
      display: block;
    }
    iframe.embed {
      width: 100%;
      height: 56.25vw;
      max-height: 56.25vw;
      border: 0;
      background: #000;
      display: none;
    }
    @media (min-width: 768px) {
      video { max-height: 480px; }
      iframe.embed { height: 480px; max-height: 480px; }
    }

    .status-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      color: var(--text);
      gap: 12px;
      transition: opacity 0.3s;
    }
    .status-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .status-text { font-size: 14px; text-align: center; padding: 0 20px; line-height: 1.5; }
    .status-text.error { color: var(--danger); }
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--line);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .controls {
      padding: 16px;
      max-width: 900px;
      margin: 0 auto;
    }
    .control-card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .control-label { font-size: 13px; color: var(--muted); margin-bottom: 4px; }
    .control-value { font-size: 15px; font-weight: 500; }

    .source-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
    .source-btn {
      padding: 8px 16px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: var(--bg);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .source-btn:active { opacity: 0.7; }
    .source-btn.active { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); }

    .action-row { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px; }
    .action-btn {
      flex: 1 1 45%;
      min-width: 160px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .action-btn:active { opacity: 0.7; }
    .action-btn.primary { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); }

    .error-card {
      background: rgba(248, 113, 113, 0.1);
      border: 1px solid rgba(248, 113, 113, 0.3);
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .error-title { font-size: 14px; font-weight: 600; color: var(--danger); margin-bottom: 8px; }
    .error-msg { font-size: 13px; color: var(--muted); white-space: pre-wrap; word-break: break-all; }
    .error-tips { margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(248, 113, 113, 0.2); font-size: 12px; color: var(--muted); line-height: 1.6; }

    .url-display { font-size: 12px; color: var(--muted); word-break: break-all; padding: 10px; background: var(--bg); border-radius: 8px; margin-top: 12px; }

    .footer-note { padding: 16px; text-align: center; font-size: 12px; color: var(--muted); }

    .inline-link {
      color: var(--accent);
      text-decoration: underline;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <a class="back-btn" href="./">â† è¿”å›</a>
    <div class="header-title" id="channelName">åŠ è½½ä¸­...</div>
  </header>

  <div class="video-container">
    <video id="video" controls playsinline></video>
    <iframe class="embed" id="ytFrame" title="YouTube Live" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
    <iframe class="embed" id="webFrame" title="Web Live" referrerpolicy="no-referrer" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>

    <div class="status-overlay" id="statusOverlay">
      <div class="spinner" id="spinner"></div>
      <div class="status-text" id="statusText">æ­£åœ¨åŠ è½½...</div>
    </div>
  </div>

  <div class="controls">
    <div class="control-card" id="infoCard">
      <div class="control-row">
        <div>
          <div class="control-label">åˆ†ç±»</div>
          <div class="control-value" id="channelCategory">-</div>
        </div>
        <div style="text-align:right;">
          <div class="control-label">çŠ¶æ€</div>
          <div class="control-value" id="playStatus">å‡†å¤‡ä¸­</div>
        </div>
      </div>
    </div>

    <div class="control-card" id="sourceCard" style="display:none;">
      <div class="control-label">é€‰æ‹©çº¿è·¯ï¼ˆæ”¯æŒè‡ªåŠ¨æµ‹é€Ÿ / è‡ªåŠ¨åˆ‡çº¿ï¼‰</div>
      <div class="source-list" id="sourceList"></div>
    </div>

    <div class="error-card" id="errorCard" style="display:none;">
      <div class="error-title">âš ï¸ æ’­æ”¾å¤±è´¥</div>
      <div class="error-msg" id="errorMsg"></div>
      <div class="error-tips">
        <strong>å¯èƒ½çš„åŸå› ï¼š</strong><br>
        â€¢ ç›´æ’­æºå·²å¤±æ•ˆæˆ–ä¸‹çº¿<br>
        â€¢ ç½‘ç»œè¿æ¥é—®é¢˜<br>
        â€¢ è·¨åŸŸé™åˆ¶ï¼ˆCORSï¼‰<br>
        â€¢ HTTPS é¡µé¢åŠ è½½ http æºä¼šè¢«æ‹¦æˆªï¼ˆæ··åˆå†…å®¹ï¼‰<br>
        â€¢ æœåŠ¡å™¨æ‹’ç»è®¿é—®/åœ°åŒºé™åˆ¶<br><br>
        <strong>å»ºè®®æ“ä½œï¼š</strong><br>
        â€¢ è®©åº”ç”¨å…ˆè‡ªåŠ¨æµ‹é€Ÿé€‰çº¿ï¼ˆæˆ–æ‰‹åŠ¨åˆ‡æ¢çº¿è·¯ï¼‰<br>
        â€¢ ä½ ä¹Ÿå¯ä»¥å¯¼å…¥è‡ªå·±çš„ m3u/m3u8 æ’­æ”¾åˆ—è¡¨<br>
        â€¢ ä¼˜å…ˆä½¿ç”¨ https çš„ HLS æºæˆ–å®˜æ–¹ç½‘é¡µç›´æ’­é¡µ
      </div>
    </div>

    <div class="action-row">
      <button class="action-btn" id="speedBtn">âš¡ æµ‹é€Ÿé€‰çº¿</button>
      <button class="action-btn" id="reloadBtn">ğŸ”„ é‡æ–°åŠ è½½</button>
      <button class="action-btn" id="retryBtn" style="display:none;">â­ï¸ ä¸‹ä¸€çº¿è·¯</button>
      <button class="action-btn" id="openTabBtn">ğŸŒ æ–°æ ‡ç­¾æ‰“å¼€</button>
      <button class="action-btn" id="openBrowserBtn">ğŸŒ æœ¬é¡µæ‰“å¼€ï¼ˆè¿”å›å¯å›ï¼‰</button>
    </div>

    <div class="url-display" id="urlDisplay">-</div>
  </div>

  <div class="footer-note">
    Safariï¼ˆiPhone/iPad/Macï¼‰åŸç”Ÿæ”¯æŒ HLSï¼›å…¶ä»–æµè§ˆå™¨ä¼šå°è¯•ä½¿ç”¨ hls.jsã€‚
    å¦‚æœæŸæ¡çº¿è·¯åœ¨æ’­æ”¾å™¨å†…æ— æ³•æ’­æ”¾ï¼ˆCORS/åœ°åŒº/é˜²ç›—é“¾/æ ¼å¼ç­‰ï¼‰ï¼Œå¯ç‚¹å‡»ä¸‹æ–¹â€œæ–°æ ‡ç­¾æ‰“å¼€â€æˆ–â€œæœ¬é¡µæ‰“å¼€ï¼ˆè¿”å›å¯å›ï¼‰â€ï¼Œä»¥æµè§ˆå™¨æ–¹å¼æ‰“å¼€åŸé“¾æ¥/åŸç½‘é¡µï¼Œç„¶åç”¨æµè§ˆå™¨è¿”å›å›åˆ°é¢‘é“åˆ—è¡¨ç»§ç»­åˆ‡æ¢ã€‚
  </div>

<script>
(function() {
  'use strict';

  const Storage = {
    get(key, def = null) {
      try {
        const v = localStorage.getItem(key);
        return v ? JSON.parse(v) : def;
      } catch { return def; }
    },
    set(key, val) {
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }
  };

  const MAX_RETRY = 3;
  const RETRY_DELAY = 2000;
  const BAD_TTL_DAYS = 7;
  const BAD_TTL_MS = BAD_TTL_DAYS * 24 * 60 * 60 * 1000;
  const PROBE_TIMEOUT_MS = 4200;

  let channel = null;
  let sources = [];
  let currentSourceIndex = 0;
  let retryCount = 0;
  let hlsInstance = null;
  let isPlaying = false;
  let manualSelected = false;
  let probing = false;

  const $ = id => document.getElementById(id);
  const video = $('video');
  const ytFrame = $('ytFrame');
  const webFrame = $('webFrame');
  const channelName = $('channelName');
  const channelCategory = $('channelCategory');
  const playStatus = $('playStatus');
  const statusOverlay = $('statusOverlay');
  const spinner = $('spinner');
  const statusText = $('statusText');
  const sourceCard = $('sourceCard');
  const sourceList = $('sourceList');
  const errorCard = $('errorCard');
  const errorMsg = $('errorMsg');
  const reloadBtn = $('reloadBtn');
  const retryBtn = $('retryBtn');
  const speedBtn = $('speedBtn');
  const openTabBtn = $('openTabBtn');
  const openBrowserBtn = $('openBrowserBtn');
  const urlDisplay = $('urlDisplay');

  const params = new URLSearchParams(location.search);
  const channelId = params.get('id');
  const legacyName = params.get('name');
  const legacyUrl = params.get('url');

  function showStatus(text, isError = false) {
    statusOverlay.classList.remove('hidden');
    spinner.style.display = isError ? 'none' : '';
    statusText.innerHTML = text;
    statusText.classList.toggle('error', isError);
    playStatus.textContent = stripTags(text);
    playStatus.style.color = isError ? 'var(--danger)' : '';
  }

  function stripTags(html) {
    return String(html || '').replace(/<[^>]*>/g, '');
  }

  function hideStatus() {
    statusOverlay.classList.add('hidden');
    playStatus.textContent = 'æ’­æ”¾ä¸­';
    playStatus.style.color = 'var(--accent)';
  }

  function showError(title, details) {
    errorCard.style.display = '';
    errorMsg.textContent = details;
    showStatus(title, true);
  }

  function hideError() {
    errorCard.style.display = 'none';
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[c]));
  }

  // ===== Bad source map =====
  function getBadMap() { return Storage.get('tv_bad_sources', {}); }

  function isUrlBad(url) {
    if (!url) return false;
    const m = getBadMap();
    const it = m[url];
    if (!it || !it.ts) return false;
    const age = Date.now() - it.ts;
    if (age > BAD_TTL_MS) return false;
    return true;
  }

  function markBad(url, reason) {
    if (!url) return;
    const m = getBadMap();
    const prev = m[url] || {};
    m[url] = { ts: Date.now(), count: (prev.count || 0) + 1, reason: String(reason || prev.reason || '') };
    Storage.set('tv_bad_sources', m);
  }

  function findNextGood(fromIndex) {
    if (!sources.length) return -1;
    for (let step = 1; step <= sources.length; step++) {
      const i = (fromIndex + step) % sources.length;
      const u = (sources[i] || {}).url;
      if (!isUrlBad(u)) return i;
    }
    return fromIndex;
  }

  // ===== Source selector render =====
  function renderSources(extraHint = null) {
    if (sources.length <= 1) {
      sourceCard.style.display = 'none';
      retryBtn.style.display = 'none';
      return;
    }

    sourceCard.style.display = '';
    retryBtn.style.display = '';

    sourceList.innerHTML = sources.map((src, i) => {
      const active = i === currentSourceIndex ? 'active' : '';
      const bad = isUrlBad(src.url) ? ' âš ï¸å¤±æ•ˆ' : '';
      const label = escapeHtml(src.label || `çº¿è·¯${i + 1}`) + bad;
      return `<button class="source-btn ${active}" data-index="${i}">${label}</button>`;
    }).join('');

    if (extraHint) {
      // optional future
    }
  }

  // ===== Cleanup =====
  function cleanup() {
    if (hlsInstance) {
      try { hlsInstance.destroy(); } catch {}
      hlsInstance = null;
    }
    try {
      video.pause();
    } catch {}
    video.removeAttribute('src');
    try { video.load(); } catch {}

    ytFrame.removeAttribute('src');
    ytFrame.style.display = 'none';

    webFrame.removeAttribute('src');
    webFrame.style.display = 'none';

    video.style.display = '';
    isPlaying = false;
  }

  // ===== Parse special source specs =====
  function parseYouTubeSpec(u) {
    const m = String(u || '').match(/^youtube:(channel|video|playlist):([A-Za-z0-9_-]+)$/i);
    if (!m) return null;
    const kind = m[1].toLowerCase();
    const id = m[2];
    if (kind === 'channel') {
      return {
        kind,
        id,
        embedUrl: `https://www.youtube.com/embed/live_stream?channel=${encodeURIComponent(id)}&autoplay=1&mute=0&playsinline=1&rel=0&modestbranding=1`,
        display: `YouTube Live (channel:${id})`
      };
    }
    if (kind === 'playlist') {
      return {
        kind,
        id,
        embedUrl: `https://www.youtube.com/embed/videoseries?list=${encodeURIComponent(id)}&autoplay=1&mute=0&playsinline=1&rel=0&modestbranding=1`,
        display: `YouTube Playlist (${id})`
      };
    }
    return {
      kind,
      id,
      embedUrl: `https://www.youtube.com/embed/${encodeURIComponent(id)}?autoplay=1&mute=0&playsinline=1&rel=0&modestbranding=1`,
      display: `YouTube Video (${id})`
    };
  }

  function parseWebSpec(u) {
    const m = String(u || '').match(/^web:(.+)$/i);
    if (!m) return null;
    const url = m[1].trim();
    if (!/^https?:\/\//i.test(url)) return null;
    return { url, display: url };
  }

  // ===== Probing (speed test) =====
  function probeWithTempVideo(url, timeoutMs) {
    return new Promise((resolve, reject) => {
      const t0 = performance.now();
      const v = document.createElement('video');
      v.muted = true;
      v.playsInline = true;
      v.preload = 'metadata';

      let done = false;
      const timer = setTimeout(() => {
        if (done) return;
        done = true;
        try { v.src = ''; } catch {}
        reject(new Error('timeout'));
      }, timeoutMs);

      const cleanupEv = () => {
        clearTimeout(timer);
        v.onloadedmetadata = null;
        v.oncanplay = null;
        v.onerror = null;
        try { v.src = ''; } catch {}
      };

      v.onloadedmetadata = () => {
        if (done) return;
        done = true;
        cleanupEv();
        resolve(performance.now() - t0);
      };
      v.oncanplay = () => {
        if (done) return;
        done = true;
        cleanupEv();
        resolve(performance.now() - t0);
      };
      v.onerror = () => {
        if (done) return;
        done = true;
        cleanupEv();
        reject(new Error('error'));
      };

      try {
        v.src = url;
        // Some browsers require calling load
        v.load();
      } catch (e) {
        cleanupEv();
        reject(e);
      }
    });
  }

  async function pickBestSourceIndex() {
    if (!sources.length) return 0;
    const candidates = sources
      .map((s, i) => ({ s, i }))
      .filter(x => !!x.s.url)
      .filter(x => !isUrlBad(x.s.url));

    const all = candidates.length ? candidates : sources.map((s, i) => ({ s, i }));

    // Skip probing for youtube/web; they are not comparable with HLS
    const probeTargets = all
      .filter(x => !parseYouTubeSpec(x.s.url))
      .filter(x => !parseWebSpec(x.s.url))
      .slice(0, 6);

    if (!probeTargets.length) return all[0].i;

    probing = true;
    showStatus('âš¡ æ­£åœ¨æµ‹é€Ÿé€‰çº¿...');

    const results = await Promise.allSettled(
      probeTargets.map(x => probeWithTempVideo(x.s.url, PROBE_TIMEOUT_MS))
    );

    probing = false;

    let best = { i: all[0].i, ms: Infinity };
    for (let k = 0; k < results.length; k++) {
      const r = results[k];
      if (r.status === 'fulfilled') {
        const ms = r.value;
        if (ms < best.ms) best = { i: probeTargets[k].i, ms };
      }
    }

    return best.i;
  }

  // ===== Player core =====
  async function playSource(index) {
    cleanup();
    hideError();

    if (index < 0 || index >= sources.length) {
      showError('æ— å¯ç”¨çº¿è·¯', 'æ²¡æœ‰é…ç½®æœ‰æ•ˆçš„æ’­æ”¾æº');
      return;
    }

    currentSourceIndex = index;
    renderSources();

    const source = sources[index];
    const url = source.url;

    if (!url) {
      showError('æ’­æ”¾åœ°å€ä¸ºç©º', 'è¯·æ£€æŸ¥é¢‘é“é…ç½®');
      return;
    }

    const yt = parseYouTubeSpec(url);
    const web = parseWebSpec(url);

    urlDisplay.textContent = yt ? yt.display : (web ? web.display : url);

    // youtube
    if (yt) {
      showStatus('æ­£åœ¨åŠ è½½ YouTube ç›´æ’­...');
      video.style.display = 'none';
      ytFrame.style.display = '';
      ytFrame.src = yt.embedUrl;
      ytFrame.onload = () => {
        hideStatus();
        isPlaying = true;
        retryCount = 0;
      };
      setTimeout(() => {
        if (!isPlaying) {
          showStatus('è‹¥é•¿æ—¶é—´é»‘å±ï¼šå¯èƒ½ç½‘ç»œå±è”½/åœ°åŒºé™åˆ¶ï¼Œæˆ–å½“å‰é¢‘é“æš‚æ— ç›´æ’­ã€‚', true);
        }
      }, 6000);
      return;
    }

    // web
    if (web) {
      showStatus(`æ­£åœ¨æ‰“å¼€å®˜æ–¹ç½‘é¡µç›´æ’­...<br><span class="inline-link" id="openNewTab">ç‚¹å‡»åœ¨æ–°æ ‡ç­¾æ‰“å¼€</span>`);
      video.style.display = 'none';
      webFrame.style.display = '';
      webFrame.src = web.url;

      // If the page forbids embedding, we may not get a useful error event; provide an escape hatch.
      setTimeout(() => {
        const a = document.getElementById('openNewTab');
        if (a) a.onclick = () => window.open(web.url, '_blank');
      }, 0);

      // If the page loads, consider it success; user interacts inside.
      webFrame.onload = () => {
        hideStatus();
        isPlaying = true;
        retryCount = 0;
      };

      // If embed is blocked, iframe may stay blank; guide user.
      setTimeout(() => {
        if (!isPlaying) {
          showStatus(`è¯¥é¡µé¢å¯èƒ½ç¦æ­¢å†…åµŒã€‚<br><span class="inline-link" id="openNewTab2">ç‚¹æ­¤åœ¨æ–°æ ‡ç­¾æ‰“å¼€</span>`, true);
          const b = document.getElementById('openNewTab2');
          if (b) b.onclick = () => window.open(web.url, '_blank');
        }
      }, 3500);
      return;
    }

    // Mixed content
    if (location.protocol === 'https:' && /^http:\/\//i.test(url)) {
      markBad(url, 'Mixed Content (http on https)');
      showError('æ’­æ”¾å¤±è´¥', 'è¯¥ç›´æ’­æºä¸º httpï¼Œåœ¨ https é¡µé¢ä¸‹ä¼šè¢«æµè§ˆå™¨æ‹¦æˆªï¼ˆæ··åˆå†…å®¹ï¼‰ã€‚è¯·æ›´æ¢ä¸º https æºã€‚');
      const next = findNextGood(currentSourceIndex);
      if (next !== currentSourceIndex) {
        setTimeout(() => { retryCount = 0; playSource(next); }, 600);
      }
      return;
    }

    if (isUrlBad(url) && sources.length > 1) {
      const next = findNextGood(currentSourceIndex);
      if (next !== currentSourceIndex) {
        showStatus('è¯¥çº¿è·¯è¿‘æœŸå¤±è´¥ï¼Œå·²è‡ªåŠ¨è·³è¿‡ï¼Œæ­£åœ¨å°è¯•ä¸‹ä¸€çº¿è·¯...', true);
        setTimeout(() => { retryCount = 0; playSource(next); }, 600);
        return;
      }
    }

    showStatus('æ­£åœ¨è¿æ¥...');

    // Native HLS (Safari)
    if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = url;

      video.onloadeddata = () => {
        hideStatus();
        isPlaying = true;
        retryCount = 0;
      };

      video.onerror = () => {
        handlePlayError('è§†é¢‘åŠ è½½å¤±è´¥', getVideoError(video.error));
      };

      try {
        await video.play();
      } catch {
        hideStatus();
      }
      return;
    }

    // hls.js fallback
    await loadHlsJs();

    if (!window.Hls) {
      showError('æ’­æ”¾å™¨åŠ è½½å¤±è´¥', 'æ— æ³•åŠ è½½ hls.js åº“');
      return;
    }

    if (!window.Hls.isSupported()) {
      showError('æµè§ˆå™¨ä¸æ”¯æŒ', 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ HLS æ’­æ”¾ï¼Œå»ºè®®ä½¿ç”¨ Safari');
      return;
    }

    hlsInstance = new window.Hls({
      enableWorker: true,
      lowLatencyMode: true,
      maxBufferLength: 30,
      maxMaxBufferLength: 60
    });

    hlsInstance.on(window.Hls.Events.MANIFEST_PARSED, () => {
      hideStatus();
      isPlaying = true;
      retryCount = 0;
      video.play().catch(() => {});
    });

    hlsInstance.on(window.Hls.Events.ERROR, (event, data) => {
      if (data && data.fatal) {
        const errorType = data.type || 'UNKNOWN';
        const errorDetails = data.details || 'Unknown error';
        handlePlayError(`HLS é”™è¯¯ (${errorType})`, errorDetails);
      }
    });

    hlsInstance.loadSource(url);
    hlsInstance.attachMedia(video);
  }

  function getVideoError(error) {
    if (!error) return 'æœªçŸ¥é”™è¯¯';
    const codes = {
      1: 'MEDIA_ERR_ABORTED - æ’­æ”¾è¢«ä¸­æ­¢',
      2: 'MEDIA_ERR_NETWORK - ç½‘ç»œé”™è¯¯',
      3: 'MEDIA_ERR_DECODE - è§£ç é”™è¯¯',
      4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - æ ¼å¼ä¸æ”¯æŒ'
    };
    return codes[error.code] || `é”™è¯¯ä»£ç : ${error.code}`;
  }

  function handlePlayError(title, details) {
    showError(title, details);

    if (retryCount < MAX_RETRY) {
      retryCount++;
      showStatus(`${escapeHtml(title)} - ${RETRY_DELAY/1000}ç§’åé‡è¯• (${retryCount}/${MAX_RETRY})...`, true);
      setTimeout(() => {
        if (!isPlaying) playSource(currentSourceIndex);
      }, RETRY_DELAY);
      return;
    }

    try { markBad((sources[currentSourceIndex] || {}).url, details || title); } catch {}

    if (sources.length > 1) {
      const next = findNextGood(currentSourceIndex);
      if (next !== currentSourceIndex) {
        showStatus('é‡è¯•æ¬¡æ•°å·²ç”¨å®Œï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€çº¿è·¯...', true);
        setTimeout(() => {
          retryCount = 0;
          manualSelected = false;
          playSource(next);
        }, RETRY_DELAY);
        return;
      }
    }

    showStatus('é‡è¯•æ¬¡æ•°å·²ç”¨å®Œï¼Œè¯·å°è¯•æ‰‹åŠ¨åˆ‡æ¢çº¿è·¯æˆ–æ›´æ¢æœ‰æ•ˆæºã€‚', true);
  }

  function loadHlsJs() {
    return new Promise(resolve => {
      if (window.Hls) return resolve();
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/hls.js@1.5.15/dist/hls.min.js';
      s.onload = resolve;
      s.onerror = resolve;
      document.head.appendChild(s);
    });
  }

  // ===== Channel loading with custom import merge =====
  function getCustomChannels() {
    return Storage.get('tv_custom_channels', []);
  }

  async function loadAllChannels() {
    const res = await fetch('./channels.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    const base = (data.channels || []);
    const custom = getCustomChannels();
    // Custom first so they override IDs if needed
    return [...custom, ...base];
  }

  async function loadChannel() {
    if (legacyUrl && !channelId) {
      channel = {
        id: 'legacy',
        name: legacyName || 'æ’­æ”¾',
        category: '',
        sources: [{ label: 'é»˜è®¤', url: legacyUrl }]
      };
      initPlayer();
      return;
    }

    if (!channelId) {
      showError('å‚æ•°é”™è¯¯', 'ç¼ºå°‘é¢‘é“ IDï¼Œè¯·ä»é¢‘é“åˆ—è¡¨è¿›å…¥');
      channelName.textContent = 'å‚æ•°é”™è¯¯';
      return;
    }

    try {
      showStatus('åŠ è½½é¢‘é“ä¿¡æ¯...');
      const all = await loadAllChannels();
      channel = all.find(ch => ch.id === channelId);

      if (!channel) {
        showError('é¢‘é“ä¸å­˜åœ¨', `æ‰¾ä¸åˆ° ID ä¸º "${channelId}" çš„é¢‘é“`);
        channelName.textContent = 'é¢‘é“ä¸å­˜åœ¨';
        return;
      }

      initPlayer();
    } catch (err) {
      showError('åŠ è½½å¤±è´¥', err.message);
      channelName.textContent = 'åŠ è½½å¤±è´¥';
    }
  }

  async function initPlayer() {
    channelName.textContent = channel.name || 'æœªå‘½åé¢‘é“';
    document.title = channel.name || 'æ’­æ”¾ä¸­';
    channelCategory.textContent = channel.category || 'æœªåˆ†ç±»';

    sources = (channel.sources || []).filter(s => s && s.url);
    sources.sort((a, b) => (a.priority || 99) - (b.priority || 99));

    if (!sources.length) {
      showError('æ— æ’­æ”¾æº', 'è¯¥é¢‘é“æ²¡æœ‰é…ç½®æœ‰æ•ˆçš„æ’­æ”¾åœ°å€');
      return;
    }

    renderSources();

    // Auto speed-select on first entry when multiple sources and not user-selected
    if (sources.length > 1) {
      const best = await pickBestSourceIndex();
      currentSourceIndex = best;
      renderSources();
      retryCount = 0;
      manualSelected = false;
      playSource(best);
    } else {
      playSource(0);
    }
  }

  // ===== Events =====
  sourceList.addEventListener('click', e => {
    const btn = e.target.closest('.source-btn');
    if (!btn) return;
    const index = parseInt(btn.dataset.index, 10);
    if (!isNaN(index) && index !== currentSourceIndex) {
      manualSelected = true;
      retryCount = 0;
      playSource(index);
    }
  });

  reloadBtn.addEventListener('click', () => {
    retryCount = 0;
    playSource(currentSourceIndex);
  });

  retryBtn.addEventListener('click', () => {
    retryCount = 0;
    const next = (currentSourceIndex + 1) % sources.length;
    manualSelected = true;
    playSource(next);
  });

  speedBtn.addEventListener('click', async () => {
    if (probing) return;
    retryCount = 0;
    const best = await pickBestSourceIndex();
    manualSelected = true;
    playSource(best);
  });



  function getOpenTargetUrl() {
    if (!sources.length) return null;
    const src = sources[currentSourceIndex] || {};
    const u = src.url || '';

    const yt = parseYouTubeSpec(u);
    if (yt) {
      // For users who can access YouTube, open the native page.
      if (yt.kind === 'channel') return 'https://www.youtube.com/channel/' + yt.id + '/live';
      if (yt.kind === 'playlist') return 'https://www.youtube.com/playlist?list=' + yt.id;
      return 'https://www.youtube.com/watch?v=' + yt.id;
    }

    const web = parseWebSpec(u);
    if (web) return web.url;

    return u || null;
  }

  openTabBtn.addEventListener('click', () => {
    const t = getOpenTargetUrl();
    if (!t) return;
    window.open(t, '_blank');
  });

  openBrowserBtn.addEventListener('click', () => {
    const t = getOpenTargetUrl();
    if (!t) return;
    // Open in the same tab (like a browser). Use Back to return.
    location.href = t;
  });

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').catch(() => {});
  }

  loadChannel();
})();
</script>
</body>
</html>
